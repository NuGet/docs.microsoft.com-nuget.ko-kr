---
title: NuGet V3 API 카탈로그 리소스
description: 카탈로그에는 모든 패키지를 만들고 nuget.org에서 삭제할 인덱스입니다.
author: joelverhagen
ms.author: jver
ms.date: 10/30/2017
ms.topic: reference
ms.reviewer: kraigb
ms.openlocfilehash: 4884de71151ee1ae3c0a78b803c9222f9c1d86ec
ms.sourcegitcommit: ef08f376688f0191a8d3d873b6a4386afd799373
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/28/2019
ms.locfileid: "66266349"
---
# <a name="catalog"></a>Catalog

합니다 **카탈로그** 만들기 및 삭제와 같은 패키지 원본에 대 한 모든 패키지 작업을 기록 하는 리소스입니다. 카탈로그 리소스에는 `Catalog` 에 입력 합니다 [서비스 인덱스](service-index.md)합니다. 이 리소스를 사용할 수 있습니다 [패키지를 게시 하는 모든 쿼리](../guides/api/query-for-all-published-packages.md)합니다.

> [!Note]
> 카탈로그 공식 NuGet 클라이언트에서 사용 되지 않으므로, 일부 패키지 소스는 카탈로그를 구현 합니다.

> [!Note]
> 현재, nuget.org 카탈로그는 중국에서 사용할 수 없습니다. 자세한 내용은 참조 하세요. [NuGet/NuGetGallery #4949](https://github.com/NuGet/NuGetGallery/issues/4949)합니다.

## <a name="versioning"></a>버전 관리

다음 `@type` 값이 사용 됩니다.

@type 값   | 노트
------------- | -----
Catalog/3.0.0 | 초기 릴리스

## <a name="base-url"></a>기준 URL

다음 Api에 대 한 항목 지점 URL의 값인 합니다 `@id` 앞에서 언급 한 리소스와 연결 된 속성 `@type` 값입니다. 자리 표시자 URL을 사용 하 여이 항목에서는 `{@id}`합니다.

## <a name="http-methods"></a>HTTP 메서드

HTTP 메서드만 카탈로그 리소스 지원에서 발견 한 모든 Url `GET` 고 `HEAD`입니다.

## <a name="catalog-index"></a>카탈로그 인덱스

카탈로그의 인덱스를 시간순으로 정렬 되는 카탈로그 항목의 목록이 있는 잘 알려진 위치에 문서를입니다. 카탈로그 리소스의 진입점 이며

인덱스는 카탈로그 페이지의 구성 됩니다. 각 카탈로그 페이지 카탈로그 항목을 포함 합니다. 카탈로그 항목에 각 시간에서 지점에서 단일 패키지와 관련 된 이벤트를 나타냅니다. 카탈로그 항목을 만든 목록에 없는, 되거나 또는 삭제 된 패키지 소스에서 패키지를 나타낼 수 있습니다. 카탈로그 항목의 순서로 처리, 클라이언트 V3 패키지 원본에 존재 하는 모든 패키지의 최신 보기를 빌드할 수 있습니다.

즉, 카탈로그 blob 같은 계층적 구조를 가집니다.

- **인덱스**: 카탈로그에 대 한 진입점입니다.
- **페이지**: 카탈로그 항목을 그룹화 합니다.
- **리프**: 단일 패키지의 상태 스냅숏이 카탈로그 항목을 나타내는 문서입니다.

각 카탈로그 개체에 라는 속성이 `commitTimeStamp` 항목이 카탈로그에 추가 된 경우를 나타내는입니다. 카탈로그 항목은 일괄 처리 커밋 이라고 카탈로그 페이지에 추가 됩니다. 동일한 커밋 모든 카탈로그 항목에 동일한 커밋 타임 스탬프 (`commitTimeStamp`) 및 커밋 ID (`commitId`). 동일한 커밋 배치 되는 카탈로그 항목에는 패키지 원본에 시간에 동일한 지점을 발생 한 이벤트를 나타냅니다. 카탈로그 커밋 내에서 순서가 있지 않습니다.

각 패키지 ID 및 버전은 고유 하므로 될 수 없으므로 둘 이상의 카탈로그 항목을 커밋. 이렇게 하면는 단일 패키지에 대 한 카탈로그 항목 항상 명확 하 게 정렬할 수 커밋 타임 스탬프 기준으로 합니다.

당 카탈로그에 둘 이상의 커밋 안는 `commitTimeStamp`합니다. 즉, 합니다 `commitId` 중복 되는 `commitTimeStamp`합니다.

달리 합니다 [패키지 메타 데이터 리소스](registration-base-url-resource.md)카탈로그는 인덱싱된 (및 쿼리할 수), 패키지 ID 기준으로 인덱싱할 시간별만 합니다.

카탈로그 항목은 항상 일정 하 게 증가 하는 시간 순서로 카탈로그에 추가 됩니다. 이 카탈로그 커밋 X 시간에서 추가 되 면 다음 카탈로그 커밋 안 함은 그 어느 때 추가 의미 X 적은 시간을 사용 하 여 합니다.

다음 요청은 카탈로그 인덱스를 페치합니다.

    GET {@id}

카탈로그 인덱스는 다음 속성을 가진 개체를 포함 하는 JSON 문서:

이름            | 형식             | 필수 | 노트
--------------- | ---------------- | -------- | -----
commitId        | string           | 예      | 가장 최신 커밋과와 연결 된 고유 ID
commitTimeStamp | string           | 예      | 최신 커밋의 타임 스탬프
count           | 정수          | 예      | 인덱스의 페이지 수
항목           | 개체의 배열 | 예      | 각 개체는 페이지를 나타내는 개체 배열

각 요소는 `items` 배열은 각 페이지에 대 한 일부 최소한의 세부 정보를 사용 하 여 개체입니다. 이러한 페이지 개체는 카탈로그 리프 (항목)를 포함 하지 않습니다. 이 배열에서 요소의 순서는 정의 되지 않았습니다. 클라이언트가 사용 하 여 메모리에서 페이지를 주문할 수 있습니다. 해당 `commitTimeStamp` 속성입니다.

새 페이지가 도입 되는 `count` 증가 하 고 새 개체에 표시 됩니다는 `items` 배열입니다.

카탈로그, 인덱스의 항목을 추가할수록 `commitId` 바뀝니다 및 `commitTimeStamp` 늘어납니다. 이러한 속성은 두 가지 요약 기본적으로 모든 페이지에 대해 `commitId` 하 고 `commitTimeStamp` 값을 `items` 배열입니다.

### <a name="catalog-page-object-in-the-index"></a>인덱스의 카탈로그 페이지 개체

카탈로그 페이지 개체 카탈로그의 인덱스 있는 `items` 속성에 다음과 같은 속성이 있습니다.

이름            | 형식    | 필수 | 노트
--------------- | ------- | -------- | -----
@id             | string  | 예      | Fetch 카탈로그 페이지 URL
commitId        | string  | 예      | 이 페이지에서 최신 커밋과 사용 하 여 연결 된 고유 ID
commitTimeStamp | string  | 예      | 이 페이지에서 최신 커밋의 타임 스탬프
count           | 정수 | 예      | 카탈로그 페이지에는 항목 수

달리 합니다 [패키지 메타 데이터 리소스](registration-base-url-resource.md) 인라인 사례 중 일부는 인덱스에 유지 하 고 카탈로그 리프 인덱스로 인라인 되지 항상 페이지를 사용 하 여 페치해야 `@id` URL입니다.

### <a name="sample-request"></a>샘플 요청

    GET https://api.nuget.org/v3/catalog0/index.json

### <a name="sample-response"></a>샘플 응답

[!code-JSON [catalog-index.json](./_data/catalog-index.json)]

## <a name="catalog-page"></a>카탈로그 페이지

카탈로그 페이지는 카탈로그 항목의 컬렉션입니다. 문서 중 하나를 사용 하 여 가져올 것을 `@id` 카탈로그 인덱스 값을 찾을 수 있습니다. 카탈로그 페이지 URL 예측할 수 없습니다 및 카탈로그 인덱스만 사용 하 여 검색 해야 합니다.

새 카탈로그 항목이 가장 높은 커밋 타임 스탬프를 사용 하 여만 카탈로그 인덱스의 페이지 또는 새 페이지에 추가 됩니다. 더 높은 커밋 타임 스탬프가 포함 된 페이지를 카탈로그에 추가 되 면 이전 페이지는 추가 되거나 변경 되지 않습니다.

카탈로그 페이지 문서는 다음 속성을 사용 하 여 JSON 개체:

이름            | 형식             | 필수 | 노트
--------------- | ---------------- | -------- | -----
commitId        | string           | 예      | 이 페이지에서 최신 커밋과 사용 하 여 연결 된 고유 ID
commitTimeStamp | string           | 예      | 이 페이지에서 최신 커밋의 타임 스탬프
count           | 정수          | 예      | 페이지의 항목 수
항목           | 개체의 배열 | 예      | 이 페이지에서 카탈로그 항목
부모(parent)          | string           | 예      | 카탈로그 인덱스에 대 한 URL

각 요소는 `items` 배열이 카탈로그 항목에 대 한 일부 최소한의 세부 정보를 사용 하 여 개체입니다. 이러한 항목 개체는 카탈로그 항목의 데이터를 모두 포함 되지 않습니다. 페이지의 항목의 순서 `items` 배열에 정의 되어 있지 않습니다. 클라이언트가 사용 하 여 메모리에 항목을 주문할 수 있습니다. 해당 `commitTimeStamp` 속성입니다.

페이지에서 카탈로그 항목 수가 서버 구현에서 정의 됩니다. Nuget.org에 대 한 항목이 최대 550 각 페이지의 실제 수 시간에서 지점에서 다음 커밋 배치의 크기에 따라 일부 페이지에 대 한 더 작은 수 있지만.

새 항목 도입 되는 `count` 에 증가 하 고 새 카탈로그 항목 개체 표시 되는 `items` 배열.

항목 페이지에 추가 되는 `commitId` 변경 내용 및 `commitTimeStamp` 증가 합니다. 이러한 속성은 두 가지 요약 기본적으로 모든 `commitId` 하 고 `commitTimeStamp` 값을 `items` 배열입니다.

### <a name="catalog-item-object-in-a-page"></a>카탈로그 페이지에 항목 개체

카탈로그 항목 개체의 카탈로그 페이지의에 있는 `items` 속성에 다음과 같은 속성이 있습니다.

이름            | 형식    | 필수 | 노트
--------------- | ------- | -------- | -----
@id             | string  | 예      | 카탈로그 항목을 인출 하는 URL
@type           | string  | 예      | 카탈로그 항목의 형식
commitId        | string  | 예      | 이 카탈로그 항목과 연결 된 커밋 ID
commitTimeStamp | string  | 예      | 이 카탈로그 항목의 커밋 타임 스탬프
nuget:id        | string  | 예      | 이 리프 관련이 있는 패키지 ID
nuget:version   | string  | 예      | 이 리프 관련 된 패키지 버전

`@type` 값은 다음 두 값 중 하나로 설정 됩니다.

1. `nuget:PackageDetails`:이에 해당 `PackageDetails` 카탈로그 리프 문서에는 형식입니다.
1. `nuget:PackageDelete`:이에 해당 합니다 `PackageDelete` 카탈로그 리프 문서에는 형식입니다.

각 유형을 의미를 참조 하는 방법에 대 한 자세한 내용은 합니다 [형식 항목에 해당](#item-types) 아래.

### <a name="sample-request"></a>샘플 요청

    GET https://api.nuget.org/v3/catalog0/page2926.json

### <a name="sample-response"></a>샘플 응답

[!code-JSON [catalog-page.json](./_data/catalog-page.json)]

## <a name="catalog-leaf"></a>카탈로그 리프

카탈로그 리프 시간에 특정 패키지 ID 및 버전 특정 시점에 대 한 메타 데이터를 포함합니다. 사용 하 여 가져올 문서가 `@id` 카탈로그 페이지에서 찾을 값입니다. 카탈로그 리프 URL 예측할 수 없습니다 및 카탈로그 페이지에 대해서만 사용 하 여 검색 해야 합니다.

카탈로그 리프 문서에는 다음 속성을 사용 하 여 JSON 개체입니다.

이름                    | 형식                       | 필수 | 노트
----------------------- | -------------------------- | -------- | -----
@type                   | 문자열 또는 문자열 배열 | 예      | 카탈로그 항목의 유형
catalog:commitId        | string                     | 예      | 이 카탈로그 항목과 연결 된 커밋 ID를
catalog:commitTimeStamp | string                     | 예      | 이 카탈로그 항목의 커밋 타임 스탬프
ID                      | string                     | 예      | 카탈로그 항목의 패키지 ID
게시               | string                     | 예      | 패키지 카탈로그 항목의 게시 날짜
버전                 | string                     | 예      | 카탈로그 항목의 패키지 버전

### <a name="item-types"></a>항목 형식

`@type` 속성은 문자열 또는 문자열 배열입니다. 편의 위해 하는 경우는 `@type` 값은 문자열, 크기 1의 모든 배열 처럼 다루어야 합니다. 모든 가능한 값에 대 한 `@type` 설명 되어 있습니다. 그러나 각 카탈로그 항목에 다음과 같은 두 가지 문자열 형식 값 중 하나만 있습니다.

1. `PackageDetails`: 패키지 메타 데이터의 스냅숏을 나타냅니다.
1. `PackageDelete`: 삭제 된 패키지를 나타냅니다

### <a name="package-details-catalog-items"></a>패키지 세부 정보 카탈로그 항목

카탈로그 항목 형식 사용 하 여 `PackageDetails` 특정 패키지 (ID 및 버전 조합)에 대 한 패키지 메타 데이터의 스냅숏을 포함 합니다. 패키지 세부 정보 카탈로그 항목을 패키지 원본에서 다음 시나리오 중 하나를 발견 한 경우에 생성 됩니다.

1. 패키지는 **푸시**합니다.
1. 패키지는 **나열 된**합니다.
1. 패키지는 **목록에 없는**합니다.
1. 패키지는 **리플로우되면서**합니다.

패키지 리플로우는 기본적으로 패키지 자체를 변경 하지 않고 기존 패키지의 가짜 밀어넣기를 생성 하는 제스처를 관리 합니다. Nuget.org는 리플로우 카탈로그를 사용 하는 백그라운드 작업 중 하나에서 버그를 해결 한 후 사용 됩니다.

이러한 시나리오 중 생성 된 카탈로그 항목을 확인 하려면 클라이언트 카탈로그 항목을 사용 하지 않아야 합니다. 대신 클라이언트 해야 카탈로그 항목에 포함 된 메타 데이터를 사용 하 여 모든 유지 관리 뷰 또는 인덱스를 업데이트 하기만 하면 됩니다. 또한 중복 되거나 중복 카탈로그 항목의 처리 정상적으로 (멱).

패키지 세부 정보 카탈로그 항목에는 다음 속성이 것 외에도 [모든 카탈로그 리프에 포함 된](#catalog-leaf)합니다.

이름                    | 형식                       | 필수 | 노트
----------------------- | -------------------------- | -------- | -----
authors                 | string                     | 아니요       |
created                 | string                     | 아니요       | 패키지를 처음 만들 때의 타임 스탬프입니다. 대체 (fallback) 속성: `published`합니다.
dependencyGroups        | 개체의 배열           | 아니요       | 동일한 형식으로 [패키지 메타 데이터 리소스](registration-base-url-resource.md#package-dependency-group)
설명             | string                     | 아니요       |
iconUrl                 | string                     | 아니요       |
isPrerelease            | boolean                    | 아니요       | 시험판 패키지 버전 인지 여부입니다. 검색할 수 `version`입니다.
language                | string                     | 아니요       |
licenseUrl              | string                     | 아니요       |
나열                  | boolean                    | 아니요       | 패키지가 나열 되는 여부
minClientVersion        | string                     | 아니요       |
packageHash             | string                     | 예      | 인코딩을 사용 하 여 패키지의 해시가 [표준 base 64](https://tools.ietf.org/html/rfc4648#section-4)
packageHashAlgorithm    | string                     | 예      |
packageSize             | 정수                    | 예      | 패키지.nupkg 바이트 크기
projectUrl              | string                     | 아니요       |
releaseNotes            | string                     | 아니요       |
requireLicenseAgreement | boolean                    | 아니요       | 가정 `false` 제외 하는 경우
요약                 | string                     | 아니요       |
태그                    | 문자열의 배열           | 아니요       |
제목                   | string                     | 아니요       |
verbatimVersion         | string                     | 아니요       | 버전 문자열은 원래.nuspec 있습니다

패키지 `version` 속성이 정규화 한 후 전체 버전 문자열입니다. 즉,이 SemVer 2.0.0 빌드 데이터를 여기 포함 될 수 있습니다.

`created` 패키지는 일반적으로 짧은 시간 카탈로그 항목의 커밋 타임 스탬프 이전의 패키지 원본에 먼저 수신 된 경우 타임 스탬프입니다.

합니다 `packageHashAlgorithm` 문자열을 생성 하는 데 해시 알고리즘을 나타내는 서버 구현에 의해 정의 되는 `packageHash`합니다. nuget.org를 항상 사용 합니다 `packageHashAlgorithm` 의 값 `SHA512`합니다.

`published` 타임 스탬프 패키지가 마지막으로 나열 된 시간입니다.

> [!Note]
> Nuget.org에서는 `published` 값 패키지 나열 되어 있지 않으면 경우 1900 년으로 설정 됩니다.

#### <a name="sample-request"></a>샘플 요청

GET https://api.nuget.org/v3/catalog0/data/2015.02.01.11.18.40/windowsazure.storage.1.0.0.json

#### <a name="sample-response"></a>샘플 응답

[!code-JSON [catalog-package-details.json](./_data/catalog-package-details.json)]

### <a name="package-delete-catalog-items"></a>패키지 카탈로그 항목 삭제

카탈로그 항목 형식 사용 하 여 `PackageDelete` 나타내는 카탈로그 클라이언트에 패키지를 패키지 소스에서 삭제 되었습니다 (예: 복원) 패키지의 작업에 대해 사용할 수 없는 정보의 최소 집합을 포함 합니다.

> [!Note]
> 삭제할 패키지 및 동일한 패키지 ID 및 버전에는 나중에 다시 게시를 사용 하 여는 것이 가능 합니다. Nuget.org의 패키지 ID 및 버전을 특정 패키지 콘텐츠 의미는 공식 클라이언트의 가정을 중단으로 매우 드문 경우입니다. Nuget.org의 패키지 삭제에 대 한 자세한 내용은 참조 하세요. [정책](../policies/deleting-packages.md)합니다.

패키지 카탈로그 항목 삭제는 것 외에도 추가 속성 없이 [모든 카탈로그 리프에 포함 된](#catalog-leaf)합니다.

`version` 속성은 패키지.nuspec 있는 원래 버전 문자열입니다.

`published` 속성이 일반적으로 카탈로그 항목의 커밋 타임 스탬프 전까지 짧은 시간으로 패키지가 삭제 된 경우에 합니다.

#### <a name="sample-request"></a>샘플 요청

GET https://api.nuget.org/v3/catalog0/data/2017.11.02.00.40.00/netstandard1.4_lib.1.0.0-test.json

#### <a name="sample-response"></a>샘플 응답

[!code-JSON [catalog-package-delete.json](./_data/catalog-package-delete.json)]

## <a name="cursor"></a>Cursor

### <a name="overview"></a>개요

이 섹션에는 있지만 반드시 프로토콜에서 위임 되지 않는 모든 실질적인 카탈로그 클라이언트 구현 해야 하는 클라이언트 개념을 설명 합니다.

클라이언트 저장 해야 카탈로그 시간을 기준으로 인덱싱된 추가 전용 데이터 구조를 이기 때문에 **커서** 로컬로 클라이언트 있는 시점까지 나타내는 처리 카탈로그 항목입니다. 이 커서 값은 생성 되지 않도록 클라이언트의 컴퓨터 시계를 사용 하는 참고 합니다. 카탈로그 개체의 값은 가져와야 하는 대신 `commitTimestamp` 값입니다.

클라이언트를 패키지 원본에 새 이벤트를 처리 하려는 때마다 필요할 카탈로그 쿼리만 커밋 타임 스탬프를 사용 하 여 모든 카탈로그 항목에 대 한 해당 저장된 커서 보다 큽니다. 클라이언트가 새 카탈로그 항목이 모두를 성공적으로 처리 후에 새 커서 값으로 처리 하는 카탈로그 항목의 최신 커밋 타임 스탬프를 기록 합니다.

이 방법을 사용 하는 클라이언트 수 패키지 소스에서 발생 한 모든 패키지 이벤트를 놓칠 일이 없습니다.
또한 클라이언트에 커서의 기록 된 커밋 타임 스탬프 하기 전에 이전 이벤트를 다시 처리할 수 없습니다.

이 강력한 개념이 커서 다양 한 nuget.org 백그라운드 작업에 사용 되 고 V3 API 자체를 최신 상태로 유지 하는 데 사용 됩니다. 

### <a name="initial-value"></a>초기 값

카탈로그 클라이언트가 처음으로 시작 됩니다 (및 따라서 값이 없는 커서) 하는 경우 기본 커서 값을 사용 해야 합니다. NET의 `System.DateTimeOffset.MinValue` 또는 유사한 일부 이러한 개념이 표현할 수 있는 최소 타임 스탬프입니다.

### <a name="iterating-over-catalog-items"></a>카탈로그 항목에 대해 반복

처리 하는 데 카탈로그 항목의 다음 집합을 쿼리하려면 클라이언트는 다음을 수행 해야 합니다.

1. 로컬 저장소에서 기록 된 커서 값을 가져옵니다.
1. 다운로드 한 카탈로그의 인덱스를 deserialize 합니다.
1. 모든 커밋 타임 스탬프를 사용 하 여 페이지를 카탈로그 찾기 *보다 큰* 커서입니다.
1. 빈 목록을 처리 하는 데 카탈로그 항목을 선언 합니다.
1. 각 카탈로그 페이지에 대해 3 단계에서 일치합니다.
   1. 다운로드 하 고 카탈로그 페이지를 역직렬화 합니다.
   1. 모든 카탈로그 항목을 커밋 타임 스탬프를 사용 하 여 찾기 *보다 큰* 커서입니다.
   1. 4 단계에서 선언 된 목록에 일치 하는 모든 카탈로그 항목을 추가 합니다.
1. 커밋 타임 스탬프 기준으로 카탈로그 항목 목록 정렬 합니다.
1. 순서로 각 카탈로그 항목을 처리 합니다.
   1. 다운로드 한 카탈로그 항목을 deserialize 합니다.
   1. 카탈로그 항목의 형식에 적절 하 게 반응 합니다.
   1. 클라이언트별 방식으로 카탈로그 항목 문서를 처리 합니다.
1. 새 커서 값으로 마지막 카탈로그 항목의 커밋 타임 스탬프를 기록 합니다.

이 기본 알고리즘을 사용 하 여 클라이언트 구현 패키지 원본에 사용할 수 있는 모든 패키지의 전체 보기를 빌드할 수 있습니다. 주기적으로 항상 알아야 할 패키지 원본에 대 한 최신 변경 내용을이 알고리즘에는 클라이언트가 실행할만 필요 합니다.

> [!Note]
> 알고리즘은이 유지 하는 nuget.org를 사용 합니다 [패키지 메타 데이터](registration-base-url-resource.md), [패키지 콘텐츠](package-base-address-resource.md)를 [검색](search-query-service-resource.md) 및 [자동 완성](search-autocomplete-service-resource.md) 최신 리소스입니다.

### <a name="dependent-cursors"></a>종속 커서

클라이언트의 출력 다른 클라이언트의 출력에 따라 달라 집니다는 내재 된 종속성을 가진 두 명의 카탈로그 클라이언트가 가정 합니다. 

#### <a name="example"></a>예제

예를 들어, nuget.org에서 새로 게시 된 패키지는 나타나지 검색 리소스 패키지 메타 데이터 리소스에 표시 되기 전에. 패키지 메타 데이터 리소스를 사용 하는 공식 NuGet 클라이언트에서 수행한 "복원" 작업 때문입니다. 고객 검색 서비스를 사용 하 여 패키지를 검색 하는 경우 이러한 패키지 메타 데이터 리소스를 사용 하 여 해당 패키지를 복원할 수 있어야 합니다. 즉, 검색 리소스 패키지 메타 데이터 리소스에 따라 달라 집니다. 각 리소스에 해당 리소스를 업데이트 하는 카탈로그 클라이언트 백그라운드 작업이 있습니다. 각 클라이언트에 자체 커서입니다.

두 리소스는 오프 검색 리소스를 업데이트 하는 카탈로그 클라이언트의 커서 카탈로그에 내장 되어 있으므로 *진행 되지 않도록 해야* 패키지 메타 데이터 카탈로그 클라이언트의 커서입니다.

#### <a name="algorithm"></a>알고리즘

이 제한은 구현 하려면 되도록 위의 알고리즘을 수정 하면 됩니다.

1. 로컬 저장소에서 기록 된 커서 값을 가져옵니다.
1. 다운로드 한 카탈로그의 인덱스를 deserialize 합니다.
1. 모든 커밋 타임 스탬프를 사용 하 여 페이지를 카탈로그 찾기 *보다 큰* 커서 **작거나 종속성의 커서입니다.**
1. 빈 목록을 처리 하는 데 카탈로그 항목을 선언 합니다.
1. 각 카탈로그 페이지에 대해 3 단계에서 일치합니다.
   1. 다운로드 하 고 카탈로그 페이지를 역직렬화 합니다.
   1. 모든 카탈로그 항목을 커밋 타임 스탬프를 사용 하 여 찾기 *보다 큰* 커서 **작거나 종속성의 커서입니다.**
   1. 4 단계에서 선언 된 목록에 일치 하는 모든 카탈로그 항목을 추가 합니다.
1. 커밋 타임 스탬프 기준으로 카탈로그 항목 목록 정렬 합니다.
1. 순서로 각 카탈로그 항목을 처리 합니다.
   1. 다운로드 한 카탈로그 항목을 deserialize 합니다.
   1. 카탈로그 항목의 형식에 적절 하 게 반응 합니다.
   1. 클라이언트별 방식으로 카탈로그 항목 문서를 처리 합니다.
1. 새 커서 값으로 마지막 카탈로그 항목의 커밋 타임 스탬프를 기록 합니다.

이 수정 된 알고리즘을 사용 하 여, 종속 카탈로그 클라이언트 시스템을 빌드할 구성할 수는 자신의 특정 인덱스, 아티팩트 등 모든 생성 수 있습니다.
